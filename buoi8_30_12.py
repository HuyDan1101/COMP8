# -*- coding: utf-8 -*-
"""buoi8_30_12.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hPZSksHE3hHKAiRFZPXt0_IvtmauFLxg
"""

#W8A1
class cylinder:
  def __init__(self, radius, height):
    self.radius = radius
    self.height = height
    self.pi = 3.14
  def surface_area(self):
    return 2 * self.pi * self.radius * (self.radius + self.height)
  def volume(self):
    return self.pi * (self.radius ** 2) * self.height
r, h = map(int, input().split())
a = cylinder(r, h)
print(a.surface_area())
print(a.volume())

#W8A2
class Date:
  def __init__(self, day, month, year):
    self.day = day
    self.month = month
    self.year = year
  def nam_nhuan(self):
    return (self.year % 4 == 0 and self.year % 100 != 0) or (self.year % 400 == 0)
  def is_valid(self):
    if self.month < 1 or self.month > 12:
      return False
    else:
      days_in_months = [31, 28, 31, 30, 31, 30 , 31, 31, 30, 31, 30, 31]
      if self.month == 2 and nam_nhuan():
        max_day = 29
      else:
        max_day = days_in_months[self.month - 1]
    return 1 <= self.day <= max_day
  def tomorrow(self):
    days_in_months = [31, 28, 31, 30, 31, 30 , 31, 31, 30, 31, 30, 31]
    if self.month == 2 and nam_nhuan():
      max_day = 29
    else:
      max_day = days_in_months[self.month - 1]
    if self.day < max_day:
      self.day += 1
    else:
      if self.month < 12:
        self.day = 1
        self.month += 1
      else:
        self.day = 1
        self.month = 1
        self.year += 1
  def __repr__(self):
    return f'{self.day:02d}/{self.month:02d}/{self.year}'
day , month, year = map(int, input().split('/'))
a = Date(day, month, year)

if not a.is_valid():
  print('INVALID')
else:
  a.tomorrow()
  print(a)

#W8A3
class point2:
  def __init__(self, x_val, y_val):
    self.x = x_val
    self.y = y_val
  def on_axis(self):
    if self.x == 0 and self.y != 0:
      print(f'điểm nằm trên trục tung')
    elif self.x != 0 and self.y == 0:
      print(f'điểm nằm trên trục hoành')
    elif self.x == 0 and self.y == 0:
      print(f'điểm là gốc tọa độ')
  def distance(self, other):
    xd = self.x - other.x
    yd = self.x - other.x
    res = (xd ** 2 + yd ** 2) ** (1/2)
    return print(f'{res:.2f}')
a, b = map(float, input().split())
p1 = point2(a,b)
p2 = point2(0, 0)
p1.on_axis()
p1.distance(p2)

#W8A4
class Calculator:
    def __init__(self, f_num, s_num):
        self.f_num = f_num
        self.s_num = s_num

    def set_numbers(self, f_num, s_num):
        self.f_num = f_num
        self.s_num = s_num

    def add(self):
        return self.f_num + self.s_num

    def subtract(self):
        return self.f_num - self.s_num

    def product(self):
        return self.f_num * self.s_num

    def divide(self):
        return self.f_num / self.s_num

    def power(self):
        return self.f_num ** self.s_num

    def mod(self):
        return self.f_num % self.s_num

    def __repr__(self):
        return f'Calculator({self.f_num}, {self.s_num})'


a, b = map(int, input().split())
c = Calculator(a, b)

while True:
    print(
        "Lựa chọn:\n"
        "1. Đổi số\n"
        "2. Tính tổng\n"
        "3. Tính hiệu\n"
        "4. Tính tích\n"
        "5. Tính thương\n"
        "6. Tính mũ\n"
        "7. Tính mod\n"
        "Thoát ?"
    )

    choice = input()

    if choice == '1':
        s, t = map(int, input().split())
        c.set_numbers(s, t)
    elif choice == '2':
        print(c.add())
    elif choice == '3':
        print(c.subtract())
    elif choice == '4':
        print(c.product())
    elif choice == '5':
        print(c.divide())
    elif choice == '6':
        print(c.power())
    elif choice == '7':
        print(c.mod())
    elif choice == 'Yes':
        break
    else:
        print("Lựa chọn không hợp lệ")

#W8A5
class ShoppingCart:
    def __init__(self):
        self.cart = []
        self.cost = []
    def add_pro(self, name, price):
        self.cart.append(name)
        self.cost.append(price)
    def del_pro(self, name):
        if name in self.cart:
            idx = self.cart.index(name)
            self.cart.pop(idx)
            self.cost.pop(idx)
    def cart_check(self):
        return self.cart
    def total_cost(self):
        return sum(self.cost)
    def empty_cart(self):
        return 'Rỗng' if not self.cart else 'Không rỗng'
    def del_all(self):
        self.cart.clear()
        self.cost.clear()
print('''Nàng muốn rời khỏi siêu thị hả?
2. Thêm sản phẩm
3. Xóa sản phẩm
4. Kiểm tra giỏ
5. Tổng tiền
6. Hiển thị giỏ
7. Xóa toàn bộ''')
a = ShoppingCart()
while True:
    choice = input()
    if choice == 'Yes':
        break
    elif choice == '2':
        pro, pri = input().split()
        a.add_pro(pro, int(pri))
    elif choice == '3':
        deleted_pro = input()
        a.del_pro(deleted_pro)
    elif choice == '4':
        print(a.empty_cart())
    elif choice == '5':
        print(a.total_cost())
    elif choice == '6':
        print(a.cart_check())
    elif choice == '7':
        a.del_all()
    else:
      print('Ý nàng là sao?')

#W8A6
class Rectangle:
  def __init__(self, w, h, k):
    self.w = w
    self.h = h
    self.k = k
  def area(self):
    res = self.w * self.k * self.h * self.k
    return f'{res:.2f}'
  def perimeter(self):
    res = (self.w + self.h) * 2 * self.k
    return f'{res:.2f}'
  def scale(self, k):
    self.w = self.w * self.k
    self.h = self.h * self.k
a, b ,c = map(float, input().split())
rec = Rectangle(a,b,c)
print(rec.area(), rec.perimeter())

#W8A7
class Fraction:
    def __init__(self, a, b, op, c, d):
        self.a = int(a)
        self.b = int(b)
        self.op = op
        self.c = int(c)
        self.d = int(d)

    def gcd(self, x, y):
        while y != 0:
            x, y = y, x % y
        return abs(x)

    def rut_gon(self, x, y):
        g = self.gcd(x, y)
        return x // g, y // g

    def add(self):
        tu = self.a * self.d + self.c * self.b
        mau = self.b * self.d
        tu, mau = self.rut_gon(tu, mau)
        return f"{tu}/{mau}"

    def sub(self):
        tu = self.a * self.d - self.c * self.b
        mau = self.b * self.d
        tu, mau = self.rut_gon(tu, mau)
        return f"{tu}/{mau}"

    def mul(self):
        tu = self.a * self.c
        mau = self.b * self.d
        tu, mau = self.rut_gon(tu, mau)
        return f"{tu}/{mau}"

    def div(self):
        tu = self.a * self.d
        mau = self.b * self.c
        tu, mau = self.rut_gon(tu, mau)
        return f"{tu}/{mau}"
a, b, op, c, d = input().split()
cal = Fraction(a, b, op, c, d)

if op == '+':
    print(cal.add())
elif op == '-':
    print(cal.sub())
elif op == '*':
    print(cal.mul())
elif op == '/':
    print(cal.div())

#W8A8
class BankAccount:
  def __init__(self, owner, initial_balance):
    self.owner = owner
    self.initial_balance = initial_balance
  def deposit(self, x):
    self.initial_balance += x
  def withdraw(self, x):
    if x <= self.initial_balance:
      self.initial_balance -= x
  def __repr__(self):
    return f'{self.initial_balance:.2f}'
name , money = input().split()
one = BankAccount(name, float(money))
rg = int(input())
for i in range(rg):
  a,b  = input().split()
  if a == 'DEPOSIT':
    one.deposit(float(b))
  elif a == 'WITHDRAW':
    one.withdraw(float(b))
print(one)

#W8A9
class Student:
  def __init__(self, name):
    self.name = name
    self.lst_score = []
  def add_score(self, subject, score):
    self.lst_score.append(float(score))
  def rep_input(self, k):
    for i in range(k):
      a, b = input().split()
      self.add_score(a, float(b))
  def rank(self):
    res = sum(self.lst_score) / len(self.lst_score)
    if res >= 8:
      return f'{res:.2f} Excellent'
    elif 8 > res >= 6.5:
      return f'{res:.2f} Good'
    elif 6.5 > res >= 5:
      return f'{res:.2f} Average'
    else:
      return f'{res:.2f} Poor'
  def __repr__(self):
    return f'{name} '+ self.rank()
name = input()
a = Student(name)
k = int(input())
a.rep_input(k)
print(a)

#W8A10
class Book:
  def __init__(self, title, author, year):
    self.title = title
    self.author = author
    self.year = year

class Library:
  def __init__(self):
    self.shelf = []

  def add(self, book):
    self.shelf.append(book)

  def count_by_name(self, name):
    count = 0
    for i in self.shelf:
      if i.author == name:
        count += 1
    return count

  def find_by_year(self, y):
    count = 0
    for i in self.shelf:
      if i.year == y:
        count += 1
    return count
k = int(input())
lib = Library()
for i in range(k):
  a, b = input().split()

  if a == 'ADD':
    title, author, year = b.split(';')
    one = Book(title, author, year)
    lib.add(one)
  if a == 'COUNT':
    print(lib.count_by_name(b))
  elif a == 'COUNTYEAR':
    print(lib.find_by_year(b))

#W8A11
import math
class Dimension3:
  def __init__(self, x, y, z):
    self.x = x
    self.y = y
    self.z = z

  def vecto(point1, point2):
        return Dimension3(
            point1.x - point2.x,
            point1.y - point2.y,
            point1.z - point2.z
        )

  def vecto_phap_tuyen(v1, v2):
        return Dimension3(
            v1.y * v2.z - v1.z * v2.y,
            v1.z * v2.x - v1.x * v2.z,
            v1.x * v2.y - v1.y * v2.x
        )

  def goc_giua_2_vecto(v1, v2):
        dot = v1.x*v2.x + v1.y*v2.y + v1.z*v2.z
        len1 = math.sqrt(v1.x**2 + v1.y**2 + v1.z**2)
        len2 = math.sqrt(v2.x**2 + v2.y**2 + v2.z**2)

        if len1 == 0 or len2 == 0:
            raise ValueError("Vectơ không được có độ dài bằng 0")

        cos_theta = dot / (len1 * len2)
        cos_theta = max(-1, min(1, cos_theta))

        angle = math.degrees(math.acos(cos_theta))
        return round(angle, 2)

A = Dimension3(*map(float, input().split()))
B = Dimension3(*map(float, input().split()))
C = Dimension3(*map(float, input().split()))
D = Dimension3(*map(float, input().split()))

AB = Dimension3.vecto(A,B)
AC = Dimension3.vecto(A,C)
BC = Dimension3.vecto(B,C)
BD = Dimension3.vecto(B,D)

ABC = Dimension3.vecto_phap_tuyen(AB, AC)
BCD = Dimension3.vecto_phap_tuyen(BC, BD)

print(Dimension3.goc_giua_2_vecto(ABC, BCD))

#W8A12
class ComplexNumber:
  def __init__(self, re, im):
    self.re = re
    self.im = im
  def tich(n1, n2):
    return ComplexNumber(n1.re * n2.re - n1.im * n2.im, n1.re * n2.im + n1.im * n2.re)
  def __repr__(self):
    return f'{self.re} {self.im}'
a = ComplexNumber(*map(float, input().split()))
b = ComplexNumber(*map(float, input().split()))
print(ComplexNumber.tich(a,b))

#W8A13
class Triangle:
  def __init__(self, e1, e2, e3):
    self.e1 = e1
    self.e2 = e2
    self.e3 = e3
  def getArea(self):
    p = ( self.e1 + self.e2 + self.e3 ) / 2
    res = (p * (p - self.e1) * (p - self.e2) * (p - self.e3)) ** 0.5
    return f'{res:.2f}' if res > 0 else 'Invalid'
tri = Triangle(*map(int, input().split()))
print(tri.getArea())
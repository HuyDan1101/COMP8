# -*- coding: utf-8 -*-
"""buoi7_23_12.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1I-yjnZ4ds6hBPS9E9Zx91_0WGF9WMPXt
"""

#W7A1
def binary_search(arr, target):
  left, right = 0, len(arr) - 1
  while left <= right:
    mid = (left + right) // 2
    if target < arr[mid]:
      right = mid - 1
    elif target > arr[mid]:
      left = mid + 1
    else:
      return mid
  return -1
arr = list(map(int, input().split()))
target = int(input())
print(binary_search(arr, target))

#W7A2
def count_occurrences(arr, x) -> int:
  count = 0
  for i in arr:
    if i == x:
      count += 1
  return count
arr = list(map(int, input().split()))
x = int(input())
print(count_occurrences(arr, x))

#W7A3
def selection_sort(a):
  for i in range(1, len(a)):
    key = a[i]
    j = i - 1
    while j >= 0 and a[j] > key:
      a[j + 1] = a[j]
      j -= 1
    a[j + 1] = key
  return print(*a)



def bubble_sort(a):
  for i in range(len(a) -1, -1, -1):
    swap = False
    for j in range(0, i ):
      if a[j] > a[j + 1]:
        a[j] , a[j+ 1] = a[j + 1], a[j]
        swap = True
    if not swap:
      break
  return print(*a)
lst = list(map(int, input().split()))
bubble_sort(lst)

#W7A4
def xuat_hien_nhieu(arr):
  a = []
  b = []
  for i in range(len(arr)):
    if arr[i] not in a:
      a.append(arr[i])
      b.append(1)
    else:
      for k in range(len(a)):
        if a[k] == arr[i]:
          b[k] += 1
  mx = 0
  mx_ap = 0
  for num in range(len(b)):
    if b[num] > mx:
      mx = b[num]
      mx_ap = a[num]
  return print(f"{mx_ap} xuat hien nhieu nhat, som nhat, {mx} lan")
lst = list(map(int, input().split()))
xuat_hien_nhieu(lst)

#W7A5
def phep_nhan():
  arr = list(map(int, input().split()))
  x = int(input())
  count = 0
  new = {}
  for i in arr:
    new[i] = new.get(i, 0) + 1
  for i in new.keys():
    for k in new.keys():
      if i + k == x:
        count += (new[i] * new[k])
  return count // 2
phep_nhan()

#W7A6
def lam_phang(lst):
    result = []
    for x in lst:
        if type(x) == list :
            result.extend(lam_phang(x))
        else:
            result.append(x)
    return result
import ast
s = input()
lst = ast.literal_eval(s)
print(lam_phang(lst))

#W7A7
def length_of_LIS(nums):
    n = len(nums)
    if n == 0:
        return 0
    dp = [1] * n
    for i in range(n):
        for j in range(i):
            if nums[j] < nums[i]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)
import ast
s = input()
lst = ast.literal_eval(s)
print(length_of_LIS(lst))

#W7A8
import ast
def abc(interval, queries):
  length = [0] * len(interval)
  for i in range(len(interval)):
    length[i] = interval[i][1] - interval[i][0] + 1
  result = []
  for i in range(len(queries)):
    shortest = []
    for j in range(len(interval)):
      if interval[j][0] <= queries[i] <= interval[j][1]:
        shortest.append(length[j])
    if shortest == []:
      result.append(-1)
    else:
      result.append(min(shortest))
  return print(result)
s = input()
a = ast.literal_eval(s)
t = input()
b = ast.literal_eval(t)
abc(a,b)

#W7A9
import ast
def smaller_nums(arr):
  result = []
  for i in range(len(arr)):
    so_nho_hon = 0
    for j in range(i+1, len(arr)):
      if arr[j] < arr[i]:
        so_nho_hon += 1
    result.append(so_nho_hon)
  return result
a = input()
b = ast.literal_eval(a)
smaller_nums(b)

#W7A10
def max_mod(nums, m):
  prefix = []
  for i in range(len(nums)):
    prefix.append((sum(nums[0:i+1])) % m)
  a = max(prefix)
  for i in range(len(prefix)):
    if prefix[i] == a:
      x = len(prefix) + 1
      b = max(prefix[i+1: x])
  return b - a + m
import ast
a = input()
b = ast.literal_eval(a)
m = int(input())
max_mod(b, m)

#W7A11
sentence = input()
word = input()

count = 0
start = 0

while True:
    pos = sentence.find(word, start)
    if pos == -1:
        break
    count += 1
    start = pos + len(word)

print(count)

#W7A12
a1 = input()
b1 = input()
c1 = input()
d1 = input()
a = {a1 : 'A', b1: 'B', c1: 'C', d1 : 'D'}
s = sorted(a.keys())
res = []
for i in s:
  res.append(a[i])
print(*res)

#W7A13
def merge(left, right):
  res = []
  i = j = 0
  while i < len(left) and j < len(right):
    if left[i] < right[j]:
      res.append(left[i])
      i += 1
    else:
      res.append(right[j])
      j += 1
  res.extend(left[i:])
  res.extend(right[j:])
  return res
def merge_sort(arr):
  if len(arr) <= 1:
    return arr
  mid = len(arr) // 2
  left = arr[:mid]
  right = arr[mid:]
  sorted_left = merge_sort(left)
  sorted_right = merge_sort(right)
  return merge(sorted_left, sorted_right)
def day_hai_hoa(arr):
  res = []
  for i in range(len(arr)):
    if arr[i] != arr[i - 1] or i == 0:
      length = 1
      for j in range(i + 1, len(arr)):
        if arr[j] == arr[i] or arr[j] == arr[i] + 1:
          length += 1
      res.append(length)
  return max(res)
b = list(map(int, input().split()))
print(day_hai_hoa(merge_sort(b)))

#W7A14
a = int(input())
lst = list(map(int, input().split()))
idx = []
for i in  range(len(lst)- 1, -1, -1):
  if lst[i] == 7:
    idx.append(i)
if idx == []:
  print('Not found')
else:
  print(*idx)

#W7A15
a = int(input())
lst = []
for i in range(a):
  lst.append(input())
for char in range(len(lst)):
  if lst[char] == 'Nemo' and char != len(lst) -1  :
    print(f'{lst[char - 1]} and {lst[char + 1]}')
  elif lst[char] == 'Nemo' and char == len(lst) -1 :
    print(f'{lst[char - 1]} and {lst[0]}')